#!/usr/bin/env python
''' Search html documents generated by clang utilities for warnings/errors
'''
import logging
import json
import hashlib
import re
from abc import ABC, abstractmethod
# bs4 will be provided in the docker image, see Dockerfile
#pylint: disable=import-error
import bs4

LOGGER = logging.getLogger()
LOGGER.setLevel(logging.INFO)
CPP_LINE_PAT = re.compile(r'''(\[([\w\/\.:]+)\])
                              (|\s->\s\[[\w\/\.:]+\]):
                              (.*)''',
                          re.X|re.I)

#pylint: disable=too-many-instance-attributes
class Warnings(ABC):
    ''' Abstract warnings in html files
    '''
    @classmethod
    def from_files(cls, files):
        ''' Create HTMLWarnings for each file-like file in files

            Positional Arguments:
                files -- list or set iterable of file-like objects to analyze
                    as an HTMLWarning

            Returns:
                list of HTMLWarnings objects
        '''
        return [cls(fobj) for fobj in files]
    @classmethod
    def from_data(cls, dictobj):
        ''' Create HTMLWarnings from a dict, usually from record['_source']
            from ElasticSearch

            Positional Arguments:
                dictobj -- dictionary comprising fields of an HTMLWarning

            Returns:
                HTMLWarnings object
        '''
        clsobj = cls()
        clsobj.uid = dictobj['_id']
        clsobj.data = dictobj['_source']
        return clsobj
    def __init__(self, report_file=None, name=None):
        ''' Initialization function

            Arguments:
            report_file -- bytes comprising an HTML file on which to run a report
        '''
        self._file = report_file
        self._name = name
        # .read() isn't thread safe, so call it immediately, if at all possible
        self._bytes = self._file.read() if report_file else None
        self._text = None
        self._data = None
        self._uid = None
    @property
    def file(self):
        ''' Propertize report file
        '''
        return self._file
    @file.setter
    def file(self, reportfile):
        ''' Allow override of report file
        '''
        self._file = reportfile
    @property
    def bytes(self):
        ''' Propertize bytestring
        '''
        if self.file and not self._bytes:
            self._bytes = self.file.read()
        return self._bytes
    @abstractmethod
    def analyze(self):
        ''' Abstract method subclasses must implement
        '''
    @property
    def data(self):
        ''' Propertize the data
        '''
        if not self._data:
            self.analyze()
        return self._data
    @data.setter
    def data(self, dictobj):
        ''' Allow setting the data property
        '''
        self._data = dictobj
    @property
    def uid(self):
        ''' Create a property which provides the hash of the warning's relevant
            fields
        '''
        if not self._uid:
            # Compute unique identifier with ONLY fileName, warningText, and
            # lineOfCode
            # NOT with lineNumber and count (if count exists yet)
            # Also order of keys matter in the json string, so
            # sort the data so (hopefully) all uids are computed in the
            # same way
            relevant_data = {i:j
                             for i, j in sorted(self.data.items())
                             if i != 'lineNumber' and i != 'count'}
            bytestring = bytes(json.dumps(relevant_data), 'utf-8')
            self._uid = hashlib.sha512(bytestring).hexdigest()
        return self._uid
    @uid.setter
    def uid(self, uniqid):
        ''' Allow the ID to be overridden in the case that the object is built
            from an ES record
        '''
        self._uid = uniqid
    def _decode(self):
        ''' If possible, decode self.bytes from UTF-8 or, failing that,
            ISO-8859-1 and return the resulting text.
        '''
        if not self.bytes:
            return
        try:
            self._text = self.bytes.decode('utf-8')
        except UnicodeDecodeError:
            # If it can't decode to utf-8, try iso-8859-1
            # If it can't do that, just bomb out
            self._text = self.bytes.decode('iso-8859-1')
    @property
    def text(self):
        ''' Propertize decoded text if possible
        '''
        if not self._text:
            self._decode()
        return self._text

class HTMLWarnings(Warnings):
    ''' Subclass of abstract Warnings class, implements specific analysis of
        HTML files produced by scan-clan
    '''
    def analyze(self):
        ''' Analyze a report file's HTML and locate and store the:
                source code file
                line number of the error in that file
                the error message
                the actual source code line creating the error
        '''
        if not self.text:
            return
        soup = bs4.BeautifulSoup(self.text, 'html.parser')
        data = {}
        data_map = {'fileName': 'File:',
                    'lineNumber': 'Location:',
                    'warning': 'Description:'}
        for i, j in data_map.items():
            data[i] = str(soup.find(attrs={'class':'rowname'},
                                    text=j).findNextSibling().string).strip()
        line_num = 'LN' + data['lineNumber'].split()[1].strip(',')
        code_snippet = ''.join(soup
                               .find(attrs={'id': line_num})
                               .findNextSibling()
                               .strings).strip()
        self._data = data
        self._data.update({'lineOfCode': code_snippet})

class CPPWarnings(Warnings):
    ''' Subclass of abstract Warnings class, implements specific analysis of
        scan-cppcheck.txt file produced by cppcheck
    '''

    # CPPCheck outputs everything in one file, one per line
    # The lines should satisfy the following regex:
    # Group 1: like "[file/path/name.cpp:123]"
    # Group 2: like "file/path/name.cpp:123"
    # Group 3: Nothing OR like " -> [file/path/name.cpp:123]"
    # Then a ":"
    # Group 4: everything else
    def analyze(self):
        ''' Analyze a file (probably scan-cppcheck.txt) and locate and store the:
                source code file
                line number of the error in that file
                the error message
        '''
        if not self.text:
            return
        lines = self.text.split('\n')
        for line in lines:
            search = re.search(CPP_LINE_PAT, line)
            if search is None:
                continue
            file_name, line_number = search.groups()[1].split(':')
            warning = search.groups()[3]
            new_warn = CPPWarnings()
            new_warn.data = {'fileName': file_name,
                             'lineNumber': line_number,
                             'warning': warning}
            yield new_warn
